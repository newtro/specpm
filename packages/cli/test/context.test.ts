import { describe, it, expect, afterEach } from 'vitest'
import { mkdtemp, rm, mkdir, writeFile, readFile } from 'node:fs/promises'
import { join } from 'node:path'
import { tmpdir } from 'node:os'
import type { SpecPackage } from 'shared'
import { generateContext } from '../src/lib/context/generator.js'
import { generateClaudeContext } from '../src/lib/context/claude.js'
import { generateCursorContext } from '../src/lib/context/cursor.js'
import { generateCopilotContext } from '../src/lib/context/copilot.js'

function makePackage(overrides: Partial<SpecPackage> = {}): SpecPackage {
  return {
    manifest: {
      name: '@auth/email-password',
      version: '1.0.0',
      description: 'Email and password authentication',
      author: 'test',
      license: 'MIT',
    },
    directory: '/tmp/test',
    entities: [
      {
        $schema: 'https://json-schema.org/draft/2020-12/schema',
        title: 'User',
        type: 'object',
        required: ['id', 'email'],
        properties: {
          id: { type: 'string', format: 'uuid' },
          email: { type: 'string', format: 'email' },
        },
      },
    ],
    states: [],
    constraints: [
      { id: 'auth-001', description: 'Passwords must be hashed', type: 'pattern', severity: 'error', check: {} },
    ],
    docs: ['# Overview\nThis is the overview.'],
    ...overrides,
  }
}

const config = { name: 'test-project', description: 'A test project' }

describe('generateContext', () => {
  it('generates markdown with preamble and spec sections', () => {
    const result = generateContext({ packages: [makePackage()], config, target: 'claude-code' })
    expect(result).toContain('# Project Specifications (Auto-generated by SpecPM)')
    expect(result).toContain('test-project')
    expect(result).toContain('@auth/email-password v1.0.0')
    expect(result).toContain('auth-001')
    expect(result).toContain('Passwords must be hashed')
    expect(result).toContain('User')
    expect(result).toContain('# Overview')
  })

  it('handles empty packages list', () => {
    const result = generateContext({ packages: [], config, target: 'claude-code' })
    expect(result).toContain('No specs installed')
  })

  it('includes entity field table', () => {
    const result = generateContext({ packages: [makePackage()], config, target: 'claude-code' })
    expect(result).toContain('| id | string (uuid) | ✓ |')
    expect(result).toContain('| email | string (email) | ✓ |')
  })
})

describe('generateClaudeContext', () => {
  const dirs: string[] = []
  afterEach(async () => {
    for (const d of dirs) await rm(d, { recursive: true, force: true })
    dirs.length = 0
  })

  it('writes .specpm/CLAUDE.md', async () => {
    const dir = await mkdtemp(join(tmpdir(), 'specpm-ctx-'))
    dirs.push(dir)
    const result = await generateClaudeContext(dir, [makePackage()], config)
    expect(result.ok).toBe(true)
    if (!result.ok) return
    const content = await readFile(result.value, 'utf-8')
    expect(content).toContain('# Project Specifications')
    expect(content).toContain('@auth/email-password')
  })
})

describe('generateCursorContext', () => {
  const dirs: string[] = []
  afterEach(async () => {
    for (const d of dirs) await rm(d, { recursive: true, force: true })
    dirs.length = 0
  })

  it('creates .cursorrules', async () => {
    const dir = await mkdtemp(join(tmpdir(), 'specpm-ctx-'))
    dirs.push(dir)
    const result = await generateCursorContext(dir, [makePackage()], config)
    expect(result.ok).toBe(true)
    const content = await readFile(join(dir, '.cursorrules'), 'utf-8')
    expect(content).toContain('BEGIN SPECPM GENERATED RULES')
    expect(content).toContain('END SPECPM GENERATED RULES')
  })

  it('preserves existing .cursorrules content', async () => {
    const dir = await mkdtemp(join(tmpdir(), 'specpm-ctx-'))
    dirs.push(dir)
    await writeFile(join(dir, '.cursorrules'), 'My custom rules\n')
    await generateCursorContext(dir, [makePackage()], config)
    const content = await readFile(join(dir, '.cursorrules'), 'utf-8')
    expect(content).toContain('My custom rules')
    expect(content).toContain('BEGIN SPECPM GENERATED RULES')
  })

  it('replaces existing generated section on re-run', async () => {
    const dir = await mkdtemp(join(tmpdir(), 'specpm-ctx-'))
    dirs.push(dir)
    await writeFile(join(dir, '.cursorrules'), 'My custom rules\n')
    await generateCursorContext(dir, [makePackage()], config)
    await generateCursorContext(dir, [makePackage()], config)
    const content = await readFile(join(dir, '.cursorrules'), 'utf-8')
    const matches = content.match(/BEGIN SPECPM GENERATED RULES/g)
    expect(matches).toHaveLength(1)
  })
})

describe('generateCopilotContext', () => {
  const dirs: string[] = []
  afterEach(async () => {
    for (const d of dirs) await rm(d, { recursive: true, force: true })
    dirs.length = 0
  })

  it('writes .github/copilot-instructions.md', async () => {
    const dir = await mkdtemp(join(tmpdir(), 'specpm-ctx-'))
    dirs.push(dir)
    const result = await generateCopilotContext(dir, [makePackage()], config)
    expect(result.ok).toBe(true)
    if (!result.ok) return
    const content = await readFile(result.value, 'utf-8')
    expect(content).toContain('# Project Specifications')
  })
})
