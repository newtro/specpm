import type { SpecPackage } from 'shared'

export interface OverrideConfig {
  extend?: Record<string, unknown>
  remove?: string[]
}

export interface ProjectConfig {
  name: string
  version?: string
  description?: string
  targets?: string[]
  overrides?: Record<string, OverrideConfig>  // keyed by package name
}

export interface GenerateContextOptions {
  packages: SpecPackage[]
  config: ProjectConfig
  target: string
}

function renderEntitySchema(entity: Record<string, unknown>): string {
  const title = (entity['title'] as string) ?? 'Unknown'
  const properties = entity['properties'] as Record<string, Record<string, unknown>> | undefined
  const required = (entity['required'] as string[]) ?? []

  let output = `#### ${title}\n\n`

  if (properties) {
    output += '| Field | Type | Required |\n'
    output += '|-------|------|----------|\n'
    for (const [name, prop] of Object.entries(properties)) {
      const type = (prop['type'] as string) ?? 'unknown'
      const format = prop['format'] ? ` (${prop['format']})` : ''
      const isRequired = required.includes(name) ? 'âœ“' : ''
      output += `| ${name} | ${type}${format} | ${isRequired} |\n`
    }
  }

  return output
}

function renderStateMachine(state: Record<string, unknown>): string {
  const id = (state['id'] as string) ?? 'unknown'
  let output = `#### State Machine: ${id}\n\n`

  const states = state['states'] as Record<string, unknown> | undefined
  if (states) {
    output += 'States: ' + Object.keys(states).join(', ') + '\n\n'
  }

  return output
}

function renderConstraints(constraints: SpecPackage['constraints']): string {
  if (constraints.length === 0) return ''

  let output = '### Constraints\n\n'
  for (const constraint of constraints) {
    const icon = constraint.severity === 'error' ? 'ðŸ”´' : 'ðŸŸ¡'
    output += `${icon} **${constraint.id}**: ${constraint.description}\n\n`
  }
  return output
}

function applyOverrides(packages: import('shared').SpecPackage[], overrides?: Record<string, OverrideConfig>): import('shared').SpecPackage[] {
  if (!overrides) return packages

  return packages.map(pkg => {
    const override = overrides[pkg.manifest.name]
    if (!override) return pkg

    let entities = [...pkg.entities]

    // Remove entities by title
    if (override.remove) {
      entities = entities.filter(e => {
        const title = (e['title'] as string) ?? (e['$id'] as string) ?? ''
        return !override.remove!.includes(title)
      })
    }

    // Extend entities: merge properties into matching entity
    if (override.extend) {
      for (const [entityTitle, extraProps] of Object.entries(override.extend)) {
        const entity = entities.find(e => (e['title'] as string) === entityTitle || (e['$id'] as string) === entityTitle)
        if (entity && typeof extraProps === 'object' && extraProps !== null) {
          const props = (entity['properties'] ?? {}) as Record<string, unknown>
          Object.assign(props, extraProps)
          entity['properties'] = props
        }
      }
    }

    return { ...pkg, entities }
  })
}

export function generateContext(options: GenerateContextOptions): string {
  const { config, target } = options
  const packages = applyOverrides(options.packages, config.overrides)
  const lines: string[] = []

  // Preamble
  lines.push('# Project Specifications (Auto-generated by SpecPM)')
  lines.push('> Do not edit. Regenerate with `specpm context`.')
  lines.push('')
  lines.push(`**Project:** ${config.name}`)
  if (config.description) {
    lines.push(`**Description:** ${config.description}`)
  }
  lines.push(`**Target:** ${target}`)
  lines.push('')

  if (packages.length === 0) {
    lines.push('No specs installed. Run `specpm install <package>` to add specifications.')
    return lines.join('\n')
  }

  // Per-spec sections
  for (const pkg of packages) {
    const { manifest } = pkg
    lines.push(`## ${manifest.name} v${manifest.version}`)
    lines.push('')
    lines.push(manifest.description)
    lines.push('')

    // Constraints first (highest priority for AI agents)
    if (pkg.constraints.length > 0) {
      lines.push(renderConstraints(pkg.constraints))
    }

    // Entities
    if (pkg.entities.length > 0) {
      lines.push('### Entities\n')
      for (const entity of pkg.entities) {
        lines.push(renderEntitySchema(entity))
      }
    }

    // State machines
    if (pkg.states.length > 0) {
      lines.push('### State Machines\n')
      for (const state of pkg.states) {
        lines.push(renderStateMachine(state))
      }
    }

    // Docs
    if (pkg.docs.length > 0) {
      lines.push('### Implementation Notes\n')
      for (const doc of pkg.docs) {
        lines.push(doc)
        lines.push('')
      }
    }

    lines.push('---\n')
  }

  return lines.join('\n')
}
